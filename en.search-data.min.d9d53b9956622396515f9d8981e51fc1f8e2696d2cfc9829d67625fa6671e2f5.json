[{"id":0,"href":"/Fuel/releases/5.1.0/","title":"5.1.0","section":"Releases","content":" Version 5.1.0 # 18 June 2022\nAnnouncement # A small release to add convenience methods for serialization and materialization. It also includes a bug fix for object collection serialization and materialization and more tests.\nChanges # Add multiple class side convenience methods to FLSerialzier Add multiple class side convenience methods to FLMaterializer Add additional serialization convenience extensions to Object Removed some obsolete code Added more tests Breaking changes # FLMaterializer\u0026gt;\u0026gt;materializeHeader now correctly answers the header instead of FLMaterializedObjects "},{"id":1,"href":"/Fuel/releases/5.0.6/","title":"5.0.6","section":"Releases","content":" Version 5.0.6 # 2 June 2022\nAnnouncement # Fixed cleanup of SystemOrganization during tests\n"},{"id":2,"href":"/Fuel/releases/5.0.5/","title":"5.0.5","section":"Releases","content":" Version 5.0.5 # 21 May 2022\nAnnouncement # Replaced #doWithIndex: in a test with #withIndexDo:.\n"},{"id":3,"href":"/Fuel/releases/5.0.3/","title":"5.0.3","section":"Releases","content":" Version 5.0.3 # 23 April 2022\nAnnouncement # Improved test case to be more compatible across versions and dialects.\n"},{"id":4,"href":"/Fuel/releases/5.0.4/","title":"5.0.4","section":"Releases","content":" Version 5.0.4 # 28 April 2022\nAnnouncement # Fixed some lint issues.\n"},{"id":5,"href":"/Fuel/releases/5.0.2/","title":"5.0.2","section":"Releases","content":" Version 5.0.2 # 15 April 2022\nAnnouncement # Added new convenience method.\nChanges # Added convenience method FLConfiguration\u0026gt;\u0026gt;onStream:. This method allows FLSerializer and FLMaterializer instances to be reused, even when setting a new stream on every invocation (this wasn\u0026rsquo;t possible with #streamFactory:). "},{"id":6,"href":"/Fuel/releases/5.0.1/","title":"5.0.1","section":"Releases","content":" Version 5.0.1 # 27 February 2022\nAnnouncement # Old code was discovered in a method extension. The code has been updated and a new test will prevent this from happening in the future.\n"},{"id":7,"href":"/Fuel/releases/5.0.0/","title":"5.0.0","section":"Releases","content":" Version 5.0.0 # 27 February 2022\nAnnouncement # Although release 5.0.0 includes only one change, but introduces a change in the serialization format.\nChanges # Added full support for stateful traits (aka \u0026ldquo;TraitsV2\u0026rdquo; in Pharo). Notes # Stateful traits have instance variables that are applied to the target class. To support this, Fuel needs to serialize additional information about traits.\nStateful traits are available in Pharo only, starting at version 8.\nOnly users that previously have experimented with Talents or serialization of anonymous classes will see a difference. However, if you\u0026rsquo;ve used Fuel to serialize traits, you will need migrate your snapshots (additional information is stored for all traits, not just for stateful ones).\n"},{"id":8,"href":"/Fuel/releases/4.1.1/","title":"4.1.1","section":"Releases","content":" Version 4.1.1 # 23 January 2022\nAnnouncement # This release contains only a fix to some tests, no change in functionality.\nChanges # Fixed class variable references in FLHookedSubstitutionTest "},{"id":9,"href":"/Fuel/releases/4.1.0/","title":"4.1.0","section":"Releases","content":" Version 4.1.0 # 03 December 2021\nAnnouncement # This release contains only one small improvement.\nChanges # FLConfiguration\u0026gt;\u0026gt;fileName: has been renamed to filePath: to better reflect its use. The comment in this method has also been updated (parts of it were outdated). "},{"id":10,"href":"/Fuel/releases/4.0.0/","title":"4.0.0","section":"Releases","content":" Version 4.0.0 # 31 October 2021\nAnnouncement # We are excited to announce Fuel 4.0.0!\nThis version brings with it some changes that we have had in mind for years, as well as support for some of the newer features of Squeak, Pharo, and the OpenSmalltalk VM.\nThere\u0026rsquo;s still a lot to document so you will have to look at the code to get started. The public API methods on FLSerializer, FLMaterializer, and FLConfiguration include comments and FLUserGuidesTest and FLConfigurationTest show off some of the most interesting scenarios (you can load tests by loading the Tests Metacello group from the baseline). If you still have questions, please get in touch.\nUnfortunately, none of us core developers use Fuel in their day jobs anymore. So it is possible that you will encounter issues, even though our test suite looks healthy. If you do, please open an issue on GitHub. We try to respond quickly.\nI want to especially thank @noha and @seandenigris for pointing out that Fuel remains an important project and for pushing me to implement support for talents.\n\u0026ndash; @theseion, on behalf of the Fuel team\nNew Features # Builder API # For this version of Fuel we have rewritten much of the setup code to provide users with a builder API. Instead of having to instantiate different classes in a specific order, there are now only two classes that users really need to know about: FLSerializer and FLMaterializer. You can configure almost anything you need on these two classes and then send #serialize or #materializeRoot as the final message to kickstart Fuel. Here are two examples from the test suite:\nobjectToSerialize := Array with: \u0026#39;hello\u0026#39; with: \u0026#39;\u0026#39; writeStream. FLSerializer new when: [ :object | object isStream ] substituteBy: [ :o | nil ]; object: objectToSerialize; fileName: \u0026#39;demo.fuel\u0026#39;; serialize. materializedObject := FLMaterializer new fileName: \u0026#39;demo.fuel\u0026#39;; materializeRoot. Object Limits # For a long time we wanted Fuel to provide the option to limit the amount of objects that would be serialized. This does nothing for you if your goal is to serialize a complete object graph. But consider an application that serializes stack traces with Fuel. Depending on the application, the object graph could be very large, or there could easily be references that lead to serialization of the entire globals dictionary. In such a case you want to serialize as much of the relevant information as possible without assigning all of the processing resources to serialization. Keeping the application running is more important than serializing a stack trace.\nWe provide two different ways of limiting the object graph.\nTotal Objects Limit # With FLSerializer\u0026gt;\u0026gt;limitObjectsTo: you set the maximum number of objects that Fuel will serialize. Think about the layout of your object graph before setting this option. Deep chains of references may cause parts of your graph to be lost that you want to keep. It is usually best to use this option in conjuntion with a depth limit. The primary reason for applying the total objects limit is to minimize the size of the resulting file and the amount of resources that go into serialization.\nDepth Limit # With FLSerializer\u0026gt;\u0026gt;limitDepthTo: you set the maximum distance from the root object that Fuel will serialize. This option is useful for trimming unnecessary information from your object graph, e.g. when serializing a stack trace.\nFull Serialization Support By Default # The Metalevel package is no more. Serialization of classes and methods is now part of the core package. There are a couple of advantages to this, one of the most interesting ones is that this makes it possible for us to support talents.\nClass And Method Serialization For Squeak # The Metalevel package has never, or at least not for a long time, worked in Squeak, which meant that Squeak users were limited to object instance graphs and global lookups. That\u0026rsquo;s fine for many cases but there are so many great things we can do with class and method serialization that it seems unfair to exclude Squeak users from the fun ;). Thanks to a more flexible approach to on-demand class compilation for tests that we implemented, it wasn\u0026rsquo;t too hard to get the tests running for Squeak and after a bit of work most of the things that work for Pharo also work for Squeak. There are some differences of course because of the differences in machinery but those will only matter in edge cases, in my opinion. At some point we will hopefully get around to documenting the differences, until then, don\u0026rsquo;t hesitate to get in touch.\nSupport For Talents And Anonymous Classes # While working on support for talents we realized that we didn\u0026rsquo;t fully support anonymous classes (as the implementation of talents is based on anonymous classes). We now fully support anonymous classes and, therefore, talents.\nNote that there are no anonymous classes, at least not officially. For our test suite we came up with a way to create anonymous classes so that our tests also succeed in Squeak. That means you can do some crazy things with Fuel and Squeak :).\nSupport For FullBlockClosure # We now support FullBlockClosure for VM\u0026rsquo;s that use the Sista bytecodes. This is an exciting development because instances of FullBlockClosure can exist in isolation, decoupling them from their associated CompiledMethod.\nSemantic Versioning # The versioning in Fuel has always been an issue, especially the version check upon materialization. While the intentions were good, in practice we didn\u0026rsquo;t pay enough attention to what a version change meant semantically. For this release we\u0026rsquo;ve decided to finally fix that and adhere to semantic versioning. From this release on we will mark changes to serialization / materialization by incrementing the major version number. Small changes, e.g. API additions, or transparent optimizations, will be marked by incrementing the minor version number. Finally, small bug fixes and similar changes without direct impact will be marked by incrementing the patch version number.\nIn line with this change, the version check upon materialization will only raise a warning when the major version number differs. In addition, most exceptions raised by Fuel have been resumable since version 3.0.3, so you can still ignore it if you need to.\nRemovals # We don\u0026rsquo;t have a lot of resources, so maintining parts of Fuel that go largely unused isn\u0026rsquo;t a good investment of our time. Often we\u0026rsquo;d also just ignore those parts when updating Fuel for new Pharo and Squeak versions, so many things outside of the core package have become outdated.\nWe have decided to remove the following packages:\nFuelDebug FuelPreview FuelProgressUpdate If you rely on any of these, please let us know.\nIssue Cleanup # We\u0026rsquo;ve closed many old issues on the GitHub issue tracker. Many of them have become obsolete or have already been addressed. Some are out of scope and, while interesting, don\u0026rsquo;t make much sense to keep around as open issues as long a no real interest in them exists. If there\u0026rsquo;s an issue that we closed that you think should be reopened, feel free to reopen it and leave a comment.\nNew Documentation Home # You are probably reading this announcement on GitHub, the new home for the project documentation. We are still in the process of moving and updating old documentation so you will probably not find all the answers you\u0026rsquo;re looking for here. If you have a suggestion on how to improve the documentation, we welcome pull requests. Or open an issue and let us know.\n"},{"id":11,"href":"/Fuel/releases/3.0.0/","title":"3.0.0","section":"Releases","content":" Version 3.0.0 # 19 February 2018\nAnnouncement # Version 3.0.0 is essentially versino 2.2.0. However, the sources are now on Github and we\u0026rsquo;ve done some work on repackaging.\nUse Metacello to install from baselin by following the instructions at https://github.com/theseion/Fuel.\n"},{"id":12,"href":"/Fuel/releases/1.9.3/","title":"1.9.3","section":"Releases","content":" Version 1.9 # 17 February 2014\nChanges: # (feature) the #fuelReplacement selector offers the ability to statically replace an object (e.g. with nil) during analysis. This can lead to significantly smaller graphs and improved speed when serializing large graphs (feature) serialize the same graph that was analyzed instead of retrazing the graph during serialization. This prevents changes in the graph from happening between analysis and serialization (change) store source when serializing CompiledMethod objects. Needed because Opal does not allow decompilation (fix) migrate variables across hierarchy (feature) Object\u0026raquo;serializeToFileNamed: shortcut for serializing arbitrary objects (fix) better compression for LargeNegativeIntegers ( https://pharo.fogbugz.com/f/cases/12052/Fuel-could-store-LargeNegativeInteger-up-to-32bits-magnitude) "},{"id":13,"href":"/Fuel/releases/1.9/","title":"1.9","section":"Releases","content":" Version 1.9 # 8 March 2013\nAnnouncement # We are happy to announce Fuel 1.9.\nThe default set of packages of this version already comes in Pharo 2.0, so you it\u0026rsquo;s not necessary to install it there. However, Fuel also works out-of-the-box in Pharo from 1.1 up to 2.0, as well as in Squeak 4.1 up to 4.4. You can see our documentation for complete installation and use guides.\nChanges: # (feature) DoIt and not-installed CompiledMethods are fully serialized by default. (fix) Date \u0026amp; DateAndTime (thanks Cami and Marcus) (already included in 1.8.1 and 1.8.2). (feature) New hooks methods #fuelNew and #fuelNew: for custom instantiation (see \u0026ldquo;Hooking instance creation\u0026rdquo; in Customizing the Graph). Globals: Added #globalEnvironment: to specify where the globals are looked-up. (see \u0026ldquo;Changing the environment\u0026rdquo; in Managing Globals) Explicit references to \u0026ldquo;Smalltalk globals\u0026rdquo; changed to \u0026ldquo;self class environment\u0026rdquo;. A SystemDictionary instance is not treated as global when it is not \u0026ldquo;Smalltalk globals\u0026rdquo;. Documentation: General update New Format Migration section. New Built-in Header Support section. (feature) Put back FLSerializer\u0026raquo;on:. (optimization) New clusters for SmallInteger. (optimization) New clusters for most common collections. (feature) Built-in support for header (See Built-in Header Support): pre and post materialization actions (clean closures). attach additional objects. materialize only the header. (fix) Safer substitutions (see FLPluggableSubstitutionTest\u0026raquo;testPrivateExcluded). (feature) Materialize .fuel files when drag\u0026amp;dropped in the image. (cleanup) Removed unneeded cluster: FLWellKnownObjectsCluster. We want to thank developers of the community that enrich the project with code, issue reports and ideas.\nHave fun!\nMartin (on behalf of Mariano and Max, who worked a lot on this version!)\n"},{"id":14,"href":"/Fuel/releases/1.8/","title":"1.8","section":"Releases","content":" Version 1.8 # 26 May 2012\nWe are proud to announce Fuel 1.8 with a lot of new features and documentation. Of course, we don\u0026rsquo;t stop working but it was time to freeze a stable version.\nFuel works out of the box in Pharo from 1.1 up to 2.0 (checked at #20094). Please check our Documentation for complete installation and use guides.\nBelow there are some remarkable changes.\nMuch more complete user guides. Improved API for customizing how graph is traced. FuelMetalevel: serialization of stuff like classes and compiled methods moved to an optional package. Customize objects to be treated as globals. Migrations: declare at materialization time class and variables renames. Weak references properly managed. Thanks to Juan Vuletich and Levente. Thanks Pavel for helping us improving FuelPackageLoader with wonderful ideas and bug reports. Serialization speed up on large graphs by using specialized collections. Thanks Levente. Encoder and Decoder: new reifications that clarify the design. Thanks Colin Putney. Optimized serialization of \u0026ldquo;clean\u0026rdquo; BlockClosures, which don\u0026rsquo;t need the whole stack of contexts. Thanks Juan Vuletich and Eliot Miranda. Added a clear error hierarchy. Debug facilities, including graph visualization using Roassal. Thanks Alexandre and Doru. Many more new tests. Including those from extension packages, we have almost 600 tests. Repository moved from \u0026lsquo; http://www.squeaksource.com/Fuel' to \u0026lsquo; http://ss3.gemstone.com/ss/Fuel'. If you are a Fuel user we are not aware of, please let us know!\nBest regards,\nMartin and Mariano\n"},{"id":15,"href":"/Fuel/releases/1.8.1/","title":"1.8.1","section":"Releases","content":" Version 1.8.1 # 26 May 2012\nAnnouncement # We want to announce Fuel release 1.8.1.\nThis release includes one fix: serialization / materialization of Date objects. The rest of the work went into making fuel work with as many images as possible. All tests run green.\nSupported and tested images: Pharo 1.1.1, 1.1.2, 1.2, 1.3, 1.4, 2.0 and Squeak 4.1, 4.2, 4.3, 4.4.\nHave fun!\nDescription same as 1.8\nfix: serialization / materialization of Date objects. do not use Pharo compatibility packages for Squeak use individual compatibility packages for Squeak new compatibility fixes supported images: Pharo 1.1.1, 1.1.2, 1.2, 1.3, 1.4, 2.0 and Squeak 4.1, 4.2, 4.3, 4.4.\n"},{"id":16,"href":"/Fuel/releases/1.7/","title":"1.7","section":"Releases","content":" Version 1.7 # 14 October 2011\nWe have released the new version 1.7 of Fuel. The list of changes includes performance optimizations, design clean-ups, and new features.\nThe FLSerializer and FLMaterializer API has changed. They are no longer implementing the algorithms but are a kind of Façade. Developer guides with examples: Getting Started and Customizing the graph. Serialization substitutions: \u0026ldquo;Store this object instead of me.\u0026rdquo; Global sends: \u0026ldquo;Restore me by sending this selector to this global\u0026rdquo; Versioning the stream: We prefix the stream with a version number that should match when loading. Performance optimizations on instances of: Word-like classes. (We thank a lot to Henrik Sperre Johansen for your help!) ByteString and Symbol. Date, Time, Duration and DateAndTime. Point and Rectangle. MethodDictionary. Now materialization is 2000x faster, thanks to its new rehash without become. Huge clean-up in Tests package. "},{"id":17,"href":"/Fuel/releases/1.6/","title":"1.6","section":"Releases","content":" Version 1.6 # 19 August 2011\nHello!\nI want to announce in this post the new release version 1.6. This version does not add any new concrete functionality but has two main achievements: a performance improvement and a design clean up.\nMany changes included in this release are part of a design clean up. They are a necessary step forward to new functionalities that are coming soon. They make code more understandable. They enable simpler extension. Happily they also helped to improve serialization performance by reducing unnecessary interactions. And it is specially important a bottleneck in graph analysis stage we have successfully attacked, obtaining great results.\nDetails:\nRemoved explicit references to cluster classes scattered around the system. For example, in previous versions Float\u0026raquo;fuelCluster has an explicit reference to FLFloatCluster. This version replaces this by a double dispatch interaction. Clusters: Better reification. Removed annoying IDs. Removed Singleton instance creation mechanism, now mappers manage uniqueness in a better way. Mappers: They were simplified. New mapping machanism inspired on Chain of Responsibility pattern. The global objects detection has been optimized considerably. Analyzer: Part of its behavior and state has been moved to a new abstraction called \u0026lsquo;clusterization\u0026rsquo;. "},{"id":18,"href":"/Fuel/releases/1.5/","title":"1.5","section":"Releases","content":" Version 1.5 # 6 July 2011\nI am happy to announce the new release version 1.5. Below is the list of changes. In next days we will update the home page with current state. For example, we have much more to show in benchmarks section. Of course, we have many ideas and new issues to keep working on Fuel.\nInitialize instances after materialization implementing #fuelAfterMaterialization. Ignore transient instance variables overriding #fuelIgnoredInstanceVariableNames. Limit serialization progress bar to update at most once every 250 milliseconds. Traits are serialized and materialized as a regular objects ( http://code.google.com/p/fuel/issues/detail?id=59). Removed mappers system cache (Eliot). Many new tests. Benchmarks: compare Fuel against StOMP, SRP, SIXX, Magma, EsAndEm and Fuel with progress bar. Benchmarks: new samples, scripts, and CSV exporter. Benchmarks: measure serialization stream size. Removed some redundant #fuelAccept:. Several aesthetic changes in protocols, categories and comments. Now #materialize answers the materialized root. Removed special cluster for HashedCollection.Now #rehash is sended via #fuelAfterMaterialization. MethodContext serialization does not serialize temps ( http://code.google.com/p/fuel/issues/detail?id=61). Classes and Traits now serialize its environment (testCreateWithSmalltalkGlobalsEnvironment). Fixed serialization of non-octet characters (testCharacter). Fixed a bug serializing the system dictionary. FLWellKnownObjectsCluster handles it. (testSmalltalkGlobals). Fixed a bug serializing class variables (testClassVariable). Fixed a bug when serializing a collection with size greater than 1^16 with repeated elements inside. Fixed testTwoCompiledMethodsReferencingSameClassVariable. Optimization: instanceIndexes are directly created with the exact size (Henrik). "},{"id":19,"href":"/Fuel/builtin-header-support/","title":"Builtin Header Support","section":"","content":"Since the graph of objects serialized in a file can be large, and it can be useful to query some small extra info, Fuel supports the possibility to easily add such information in a header. The following examples show this set of features:\n| serializer | serializer := FLSerializer newDefault. serializer header at: #timestamp putAdditionalObject: TimeStamp now. serializer header addPreMaterializationAction: [ Transcript show: \u0026#39;Before serializing\u0026#39;; cr ]. serializer header addPostMaterializationAction: [ :materialization | Transcript show: \u0026#39;Serialized at \u0026#39;; show: (materialization additionalObjectAt: #timestamp); cr; show: \u0026#39;Materialized at \u0026#39;; show: TimeStamp now; cr ]. serializer serialize: \u0026#39;a big amount of data\u0026#39; toFileNamed: \u0026#39;demo.fl\u0026#39; Then, you can just materialize the header info:\n| aHeader | aHeader := FLMaterializer materializeHeaderFromFileNamed: \u0026#39;demo.fl\u0026#39;. aHeader additionalObjectAt: #timestamp. Printing it, the result is:\n\u0026#39;28 March 2013 12:44:54 pm\u0026#39; If we normally materialize the whole file with:\nFLMaterializer materializeFromFileNamed: \u0026#39;demo.fl\u0026#39; Then, the print of the results is:\n\u0026#39;a big amount of data\u0026#39; And this is shown in Transcript:\nBefore serializing Serialized at 28 March 2013 12:50:50 pm Materialized at 28 March 2013 1:01:21 pm For additional examples, you can see tests in FLHeaderSerializationTest. "},{"id":20,"href":"/Fuel/customizing-the-graph/","title":"Customizing the Graph","section":"","content":" Ignoring Instance Variables # It can happen that instance variables should never be serialized. A practical way to do this is overriding the hook method #fuelIgnoredInstanceVariableNames. Let\u0026rsquo;s say we have the class User and we do not want to serialize the instance variables \u0026lsquo;acumulatedLogins\u0026rsquo; and \u0026lsquo;applications\u0026rsquo;. So we implement:\nUser class \u0026gt;\u0026gt; fuelIgnoredInstanceVariableNames ^#(\u0026#39;acumulatedLogins\u0026#39; \u0026#39;applications\u0026#39;) When materialized, such instance variables will be nil. If you want to re-initialize and set values to those instance variables, you can use #fuelAfterMaterialization for that.Be aware that in case of renaming those instance variables, you should rename that method as well. Notice also that the method #fuelIgnoredInstanceVariableNames is implemented at class side. This means that all instances of such class will ignore the defined instances variables. We test this feature in FLIgnoredVariablesTest.In StOMP serializer this same hook is called #stompTransientInstVarNames and in SIXX it is #sixxIgnorableInstVarNames. Post-Materialization Action The method #fuelAfterMaterialization lets us execute something once an object has been materialized. For example, let\u0026rsquo;s say we would like to set back the instance variable \u0026lsquo;acumulatedLogins\u0026rsquo; during materialization. Hence, we can implement:\nUser \u0026gt;\u0026gt; fuelAfterMaterialization acumulatedLogins := 0. Substitution on Serialization # Sometimes you may want to serialize something different than the original object, without altering them.\nDynamic way # You can establish a pluggable substitution to a particular serialization. Let\u0026rsquo;s illustrate with an example, where your graph includes a Stream and you want to serialize nil instead.\nobjectToSerialize := Array with: \u0026#39;hello\u0026#39; with: \u0026#39;\u0026#39; writeStream. FileStream forceNewFileNamed: \u0026#39;demo.fuel\u0026#39; do: [ :aStream | aSerializer := FLSerializer newDefault. aSerializer analyzer when: [ :o | o isStream ] substituteBy: [ :o | nil ]. aSerializer serialize: objectToSerialize on: aStream binary ]. So, when loading you will get #('hello' nil), without any instance of a stream.You can find this code in FLUserGuidesTest\u0026gt;\u0026gt;testPluggableSubstitution.\nStatic way # You have to override #fuelAccept: in the class of the object to be substituted. Fuel visits each object in the graph by sending this message, to determine how to trace and serialize it. Note that this will affect every serialization, in contrast with the \u0026lsquo;dynamic way\u0026rsquo; we explained above; but it could be much faster.As an example, imagine we want to replace an object directly with nil. In other words, we want to make a whole object transient, say CachedResult. For that, we should implement:\nCachedResult \u0026gt;\u0026gt; fuelAccept: aGeneralMapper ^ aGeneralMapper visitSubstitution: self by: nil As another example, we have a Proxy class and when serializing we want to serialize its target instead of the proxy. So we implement:\nProxy \u0026gt;\u0026gt; fuelAccept: aGeneralMapper ^ aGeneralMapper visitSubstitution: self by: target Notice that #fuelAccept: is the same as the previous example. The last example is when an object needs to change the value of its instance variables. Say we have again the class User and we want to nil the instance variable \u0026lsquo;history\u0026rsquo; when its size is greater than 100.\nUser \u0026gt;\u0026gt; fuelAccept: aGeneralMapper ^self history size \u0026gt; 100 ifTrue: [ aGeneralMapper visitSubstitution: self by: (self copy history: Array new) ]. ifFalse: [ super fuelAccept: aGeneralMapper ] Note we are substituting the original user by another instance of User, which Fuel will visit with the same #fuelAccept: method. We could easily fall in an infinite sequence of substitutions if we don\u0026rsquo;t take care. To avoid this problem, it is useful #visitSubstitution:by:onRecursionDo:, where you define an alternative mapping for the case of mapping an object which is already a substitute of another one:\nUser \u0026gt;\u0026gt; fuelAccept: aGeneralMapper aGeneralMapper visitSubstitution: self by: (self copy history: #()) onRecursionDo: [ super fuelAccept: aGeneralMapper ] In the case, the substitute user (i.e. the one with the empty history) is will be visited via its super implementation.You can see tests for this functionality at FLHookedSubstitutionTest.\nSubstitution on Materialization # Global Sends # Suppose we have a special instance of User that represents the admin user, and it is an unique instance in the image. In case the admin user is referenced in our graph, we want to treat that object as a global. We can do that in this way:\nUser \u0026gt;\u0026gt; fuelAccept: aGeneralMapper ^self == User admin ifTrue: [ aGeneralMapper visitGlobalSend: self name: #User selector: #admin ] ifFalse: [ super fuelAccept: aGeneralMapper ] So what will happen is that during serialization, the admin user won\u0026rsquo;t be completly serialized (with all its intance variables) but instead its global name and selector are stored. Then, at materialization time, Fuel will send #admin to the class User, and use what that answers as the admin user of the materialized graph. We test this feature in FLGlobalSendSerializationTest.\nHooking instance creation # Fuel provides two hook methods to customise how instances are created: #fuelNew and #fuelNew:. For (regular) fixed objects, the method #fuelNew is defined in Behavior as:\nfuelNew ^ self basicNew But we can override it to our needs, for example:\nfuelNew ^ self uniqueInstance This similarly applies to variable objects through the method #fuelNew:, which by default answers #basicNew:. We test this feature in FLSingletonTest.\nNot Serializable Objects # You may want to be sure that some objects are not serialized. For this case we provide #visitNotSerializable:, which in next example forbids serialization of any instance of MyNotSerializableObject.\nMyNotSerializableObject \u0026gt;\u0026gt; fuelAccept: aGeneralMapper aGeneralMapper visitNotSerializable: self We test this feature in FLBasicSerializationTest\u0026gt;\u0026gt;testNotSerializableObject.\n"},{"id":21,"href":"/Fuel/debugging/","title":"Debugging","section":"","content":"There are a couple of packages that help us debugging Fuel. To understand the output of the tools in this guide, you should know some basics of how Fuel internally works.\nSerialization # The most important thing to remark is that serialization is split in two main steps: analysis and encoding.\nAnalysis # It consists in a graph iteration, mapping each traversed object to its correspondent grouping, called cluster.\nEncoding # After analysis, we linearly write on the stream, in these steps:\nheader for each cluster, instances part for each cluster, references part trailer Materialization # It consists on progressively recreating the graph.\nDecoding # This is done by linearly reading from the stream. So, steps are obviously analogous to the ones above:\nheader for each cluster, instances part for each cluster, references part trailer Debug Tools # Ensure you have them with:\n(ConfigurationOfFuel project version: \u0026#39;1.8.1\u0026#39;) load: #(FuelDebug FuelPreview). Next, a transcript of some useful class comments. FLGraphViewBuilder I add draw capabilities to analysis in FuelDebug package.Right-click a node for inspect it. Some examples: (FLAnalyzer newDefault setDebug; analysisFor: #((1) (2) (3) (4))) open. (FLAnalyzer newDefault setDebug; analysisFor: #((1) (2) (3) (4))) openPathsTo: 3. (FLAnalyzer newDefault setDebug; analysisFor: #((1) (2) (3) (4))) openPathsToEvery: [:o | o isNumber and: [o \u0026gt; 2] ]. They look like: Fuel Preview FLDebugSerialization # I am a serialization which facilitates debugging, by logging the stream position before and after main steps of FLSerialization, including cluster information. Obviously, you should be familiar with such class and the algorithm to understand the output log.To use, send #setDebug to your serializer and run as usually. For example:\nFileStream forceNewFileNamed: \u0026#39;debug.fuel\u0026#39; do: [:aFile | FLSerializer newDefault setDebug; serialize: \u0026#39;\u0026#39;hello\u0026#39;\u0026#39; on: aFile binary ] Then, inspect the output log:\nFLDebugSerialization last log FLDebugMaterialization # I am a materialization which facilitates debugging, by logging the stream position before and after main steps of FLMaterialization, including cluster information. Obviously, you should be familiar with such class and the algorithm to understand the output log.To use, send #setDebug to your serializer and run as usually. For example:\nFileStream oldFileNamed: \u0026#39;debug.fuel\u0026#39; do: [:aFile | FLMaterializer newDefault setDebug; materializeFrom: aFile binary ] Then, inspect the output log:\nFLDebugMaterialization last log There are a couple of packages that help us debugging Fuel. To understand the output of the tools in this guide, you should know some basics of how Fuel internally works.\n"},{"id":22,"href":"/Fuel/errors/","title":"Errors","section":"","content":"We provide a hierarchy of errors which allow to clearly identify the problem if something went wrong:\nFLError FLSerializationError FLNotSerializable FLObjectNotFound FLObsolete FLMaterializationError FLBadSignature FLBadVersion FLClassNotFound FLGlobalNotFound FLMethodChanged FLMethodNotFound As most classes of Fuel, they have class comments that give an idea their meanings: FLError # I represent an error produced during Fuel operation.\nFLSerializationError # I represent an error happened during serialization.\nFLNotSerializable # I represent an error which may happen while tracing in the graph an object that is forbidden of being serialized.\nFLObjectNotFound # I represent an error which may happen during serialization, when trying to encode on the stream a reference to an object that should be encoded before, but it is not. This usually happens when the graph changes during serialization. Another possible cause is a bug in the analysis step of serialization.\nFLObsolete # I am an error produced during serialization, signaled when trying to serialize an obsolete class as global. It is a prevention, because such class is likely to be absent during materialization.\nFLMaterializationError # I represent an error happened during materialization.\nFLBadSignature # I represent an error produced during materialization when the serialized signature doesn\u0026rsquo;t match the materializer\u0026rsquo;s signature (accessible via FLMaterializer\u0026raquo;signature). A signature is a byte prefix that should prefix a well-serialized stream.\nFLBadVersion # I represent an error produced during materialization when the serialized version doesn\u0026rsquo;t match the materializer\u0026rsquo;s version (accessible via FLMaterializer\u0026raquo;version). A version is encoded in 16 bits and is encoded heading the serialized stream, after the signature.\nFLClassNotFound # I represent an error produced during materialization when a serialized class or trait name doesn\u0026rsquo;t exist.\nFLGlobalNotFound # I represent an error produced during materialization when a serialized global name doesn\u0026rsquo;t exist (at Smalltalk globals).\nFLMethodChanged # I represent an error produced during materialization when is detected a change in the bytecodes of a method serialized as global. This error was born when testing the materialization of a BlockClosure defined in a method that changed. The test produced a VM crash.\nFLMethodNotFound # I represent an error produced during materialization when a serialized method in a class or trait name doesn\u0026rsquo;t exist (at Smalltalk globals).\n"},{"id":23,"href":"/Fuel/format-migration/","title":"Format Migration","section":"","content":"Until now, each Fuel version has its own stream format. Furthermore, each version is not compatible with the others. This means that when upgrading Fuel version, we will need to convert our serialized streams. We include below an example of migration. Let\u0026rsquo;s say we have some files serialized with Fuel 1.7 in a Pharo 1.4 image and we want to migrate them to Fuel 1.9.\n| oldVersion newVersion fileNames objectsByFileName materializerClass serializerClass | oldVersion := \u0026#39;1.7\u0026#39;. newVersion := \u0026#39;1.9\u0026#39;. fileNames := #(\u0026#39;a.fuel\u0026#39; \u0026#39;b.fuel\u0026#39; \u0026#39;c.fuel\u0026#39; \u0026#39;d.fuel\u0026#39; \u0026#39;e.fuel\u0026#39;). objectsByFileName := Dictionary new. (ConfigurationOfFuel project version: oldVersion) load. materializerClass := Smalltalk at: #FLMaterializer. fileNames do: [ :fileName | objectsByFileName at: fileName put: (materializerClass materializeFromFileNamed: fileName) ]. (ConfigurationOfFuel project version: newVersion) load. serializerClass := Smalltalk at: #FLSerializer. objectsByFileName keysAndValuesDo: [ :fileName :objects | serializerClass serialize: objects toFileNamed: \u0026#39;migrated-\u0026#39;, fileName ]. Note 1: We assume in this example that the number of objects to migrate can be materialized all together at the same time. This can be false. In such case, we could fix the script to split the list of files and do it in parts.Note 2: It is necessary to fetch the classes in the System Dictionary after the desired Fuel version has been loaded.Note 3: This script should be evaluated in the original image. For example, we don\u0026rsquo;t guarantee that Fuel 1.7 loads in Pharo 2.0, but we know that Fuel 1.9 loads in Pharo 1.4.\n"},{"id":24,"href":"/Fuel/managing-globals/","title":"Managing Globals","section":"","content":"Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.\nDefault globals # By default, Fuel considers following objects as globals, i.e. will store just its name:\nnil, true, false, and Smalltalk globals. Any Class, Trait, Metaclass or ClassTrait. Any CompiledMethod (except when either it #isInstalled not or #isDoIt, for example, the code is evaluated from Workspace). Some well-known global variables: Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World. Custom globals are duplicated In this following code snippet we show that by default the global value is not serialized as a global, and so it is duplicated on materialization. \u0026#34;Define a global variable named #SomeGlobal.\u0026#34; SomeGlobal := Set new. \u0026#34;Serialize and materialize the value of #SomeGlobal.\u0026#34; FLSerializer serialize: SomeGlobal toFileNamed: \u0026#39;g.fuel\u0026#39;. \u0026#34;The materialized object *is not* the same as the global instance.\u0026#34; [ (FLMaterializer materializeFromFileNamed: \u0026#39;g.fuel\u0026#39;) ~~ SomeGlobal ] assert. But\u0026hellip; How to avoid duplication Instead, in the code below #considerGlobal: is used to specify that it should be stored as global.\n| aSerializer | \u0026#34;Define a global variable named #SomeGlobal.\u0026#34; SomeGlobal := Set new. aSerializer := FLSerializer newDefault. \u0026#34;Tell the serializer to consider #SomeGlobal as global.\u0026#34; aSerializer analyzer considerGlobal: #SomeGlobal. aSerializer serialize: SomeGlobal toFileNamed: \u0026#39;g.fuel\u0026#39;. \u0026#34;In this case, the materialized object *is* the same as the global instance.\u0026#34; [ (FLMaterializer materializeFromFileNamed: \u0026#39;g.fuel\u0026#39;) == SomeGlobal ] assert. This feature is tested in tests-globals protocol of FLBasicSerializationTest as well in FLGlobalEnvironmentTest. Changing the environment It is possible to specify where the global will be looked-up during materialization. The method #globalEnvironment: exists for that purpose, as the following example shows.\n| aSerializer aMaterializer anEnvironment | \u0026#34;Define a global variable named #SomeGlobal.\u0026#34; SomeGlobal := Set new. \u0026#34;Tell the serializer to consider #SomeGlobal as global.\u0026#34; aSerializer := FLSerializer newDefault. aSerializer analyzer considerGlobal: #SomeGlobal. aSerializer serialize: SomeGlobal toFileNamed: \u0026#39;g.fuel\u0026#39;. \u0026#34;Override value for #SomeGlobal.\u0026#34; anEnvironment := Dictionary newFrom: Smalltalk globals. anEnvironment at: #SomeGlobal put: {42}. \u0026#34;In this case, the materialized object *is the same* as the global instance.\u0026#34; FileStream oldFileNamed: \u0026#39;g.fuel\u0026#39; do: [ :aStream | aStream binary. aMaterializer := FLMaterializer newDefault. \u0026#34;Set the environment\u0026#34; aMaterializer globalEnvironment: anEnvironment. [ (aMaterializer materializeFrom: aStream) root = {42} ] assert ] This feature is tested in the class FLGlobalEnvironmentTest. The global environment can be setted also for serialization (not only materialization), but we don\u0026rsquo;t include an example for that case. Let us assume a CompiledMethod is referenced from the graph to serialize. Sometimes we may be interested in storing just the selector and name of the class, because we know it will be present when materializing the graph. However, sometimes we want to really store the method with full detail.\nThis means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this.\n"},{"id":25,"href":"/Fuel/migration/","title":"Migration","section":"","content":"Often, we need to load objects whose class has changed since it was saved. In this document how to load them in the different cases. The figure below is useful to explain some of them. Imagine we serialized an instance of Point and we need to materialize it when Point class has changed.\nShapeChanges # Let\u0026rsquo;s start with the easier cases. If a variable was inserted, its value will be nil. If removed, it is also obvious: the serialized value will be ignored. In the case the variables are the same the the order changed, Fuel also tolerates it automatically.A more interesting case is when a variable was renamed, where the user can map old names to new ones. In our example:\nFLMaterializer newDefault migrateClassNamed: #Point variables: {\u0026#39;x\u0026#39; -\u0026gt; \u0026#39;posX\u0026#39;. \u0026#39;y\u0026#39; -\u0026gt; \u0026#39;posY\u0026#39;}. Not surprisingly, if nothing specified the change will be understood by Fuel as two independent operations, an insertion and a removal.The last change in the figure is a class rename. This should be specified this way:\nFLMaterializer newDefault migrateClassNamed: #Point toClass: Coordinate. It is also available #migrateClassNamed:toClass:variables: to combine both class and variable rename.Although not illustrated in the figure, a class could also change its layout. For example, Point could change from being fixed to variable. This should be also automatically tolerated by Fuel. Unfortunately, the inverse (variable to fixed) is not supported so far.You can find tests related to this guide in FLMigrationTest. Additionally, the method globalEnvironment:, showed in Managing Globals, might be useful for migrations: you can prepare an ad-hoc environment dictionary with the same keys that were used during serialization, but with the new classes as values.\n"},{"id":26,"href":"/Fuel/package-overview/","title":"Package Overview","section":"","content":"Fuel is a general purpose serializer and it is highly customizable to cope with different objects and scenarios. Below we describe the main packages that are available in our repository. For simplicitly we omit testing packages.\nFuel # This is the \u0026ldquo;core\u0026rdquo; of Fuel. It works as a general purpose serializer and all it does is serialize and materialize. If the graph you provide to serialize contains classes, they will all be considered as \u0026ldquo;global\u0026rdquo;. That is, in serialization we just store its global name and during materialization we read the global name and we search it in Smalltalk globals. Therefore, classes have to be present in the image you are materializing. For most users this package should be enough.\nFuelMetalevel # This is an extension to Fuel package and what it does is to add the knowledge of how to correctly serialize and materialize classes, traits, method dictionaries, compiled methods etc. It knows how to serialize a class and correctly materialize it. However, FuelMetalevel just do that: serialize and materialize. Nothing else. It does not send class side #initialize, it does not notify the system, it does not add the class to Smalltalk globals, no nothing.\nFuelPreview # It is a package to visualize the objects graphs being serialized. This is very useful to understand the transitive closure it is being serialized. This package depends on Roassal, a new visualization engine. FuelPreview is not installed by default, see more information in our Debugging guide.\nFuelBenchmarks # Fuel contains a large suite of benchmarks that analyzes the speed of the serialization/materialization and the resulted size of the stream. It can be used to benchmark itself by comparing the results with previous versions or after certain change. For important changes we always run these benchmarks to see if we have not significantly decreased in performance. In addition, we have created adaptors so that we can benchmark Fuel agains other serializers. For more details read the class comments of FLBenchmarks.\nFuelExamples # It is a small package that just contains some examples so that you can get started. Nevertheless, we recommend you to read the tests in case of more detailed scenarios.\nFuelProgressUpdate # This is a small package that adds to Fuel the possibility of showing a smart progress bar while the graph is being serialized or materialized. This is very useful for really large serializations like the case of Moose models where you want to inform the user the progress.\n"},{"id":27,"href":"/Fuel/releases/1.4/","title":"1.4","section":"Releases","content":" Version 1.4 # 1 June 2011\nOpening our News section, this post announces a new release version in ConfigurationOfFuel. It is the 1.4 and includes this list of changes:\nSerialization in memory. Important refactorings done in various hierarchies and protocols. Hack to avoid several OrderedCollection \u0026raquo; makeRoomAtLast during deserialization. Small code cleanups. To expand on the topic of serialization in memory, I give an example:\naByteArray := FLSerializer serializeInMemory: sourceObject. And then:\nloadedObject := FLMaterializer materializeFromByteArray: aByteArray. The idea is to provide protocol for NoSQL databases, where the graph is stored as a blob and not on a stream.\n"}]